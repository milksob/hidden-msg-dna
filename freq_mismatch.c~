#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>


int open_file(int argc, char *argv[])
{
  if (argc < 2)
    {
      printf("Usage: %s filename\n", argv[0]);
      return 0;
    }
  int fd = open(argv[1], O_RDONLY);
  if (fd == -1)
    printf("Can't open file %s\n", argv[1]);
  return fd;
}

int read_file(int fd, char *buf, int buf_size)
{
  if (fd == -1)
    return 0;

  int len = read(fd, buf, buf_size);

  if (len == -1)
    {
      printf("Error reading file\n");
      exit(0);
    }
  if (len == buf_size)
    {
      printf("File is too big\n");
      exit(0);
    }
  return len;
}

//returns line start
char * find_line_start(char *buf_start, char *buf_end)
{
  while (*buf_end != '\n')
    {
      --buf_end;
      if (buf_start == buf_end)
	{
	  printf("Wrong file format\n");
	  exit(0);
	}
    }
  ++buf_end;
  return buf_end;
}

enum { BUF_SIZE = 5*1024*1024 }; //x mb


// 2 bits representation
typedef enum Base { A, C, G, T, KMER_SIZE = 2 } Base;
Base calc(char ch)
{
  switch (ch)
    {
    case 'A':
      return A;
    case 'C':
      return C;
    case 'G':
      return G;
    case 'T':
      return T;
    }
  printf("Wrong input %c\n", ch);
  exit(0);
}

void print_clump(int kmer_idx, int k)
{
  char buf[k+1];
  buf[k] = 0;
  static const char labels[] = { 'A', 'C', 'G', 'T' };
  while (k--)
    {
      buf[k] = labels[kmer_idx & 0x03];
      kmer_idx >>= 2;
    }
  printf("%s\n", buf);
}

void inc_neighbours(unsigned int kmer, unsigned int k, unsigned int d, unsigned int *tmap)
{
  unsigned int kmask = (1 << 2*k) - 1;
  while (d > 0)
    {
      unsigned int dmask = (1 << d) - 1;
      while (dmask < kmask)
	{
	  unsigned int flip_stop = (1 << 2*d);
	  unsigned int flip_map = 0;
	  for (; flip_map < flip_stop; ++flip_map);
	  {
	    // get i nuc, check mask, check idx, count
	    //	  unsigned int pos_mask = 0x03;
	    unsigned int neighbour = kmer;
	    unsigned int dbit;
	    for (dbit = 0x01; dbit < dmask; dbit <<= 1)
	      {
		if (dbit & dmask == 0)
		  continue;

		unsigned flip_mask = (dbit << dbit);
		flip_mask |= flip_mask >> 1;

		const unsigned int flipc = flip_map & flip_mask;
		const unsigned int kmerc = kmer & flipc;

		if (flipc == kmerc)
		  continue;
	      
		neighbour &= ~(flip_mask);
		neighbour |= flipc;
	      }
	    if (neighbour != kmer)
	      {
		print_clump(neighbour, k);
		++tmap[neighbour];
	      }
	  }
	  //lexicograph next permutation
	  unsigned int t = dmask | (dmask - 1); // t gets v's least significant 0 bits set to 1
	  // Next set to 1 the most significant bit to change, 
	  // set to 0 the least significant ones, and add the necessary 1 bits.
	  dmask = (t + 1) | (((~t & -~t) - 1) >> (__builtin_ctz(dmask) + 1)); 
	}
      --d;
    }
}

int main(int argc, char **argv)
{
  int fd = open_file(argc, argv);

  char buf[BUF_SIZE];
  int len = read_file(fd, buf, sizeof(buf));

  char *vars = find_line_start(buf, buf + len - 2);
  int k, d;
  sscanf(vars, "%d %d", &k, &d);
  --vars;
  *vars = '\0';
  char *genome = buf;

  size_t tmap_size = pow(4, k) * sizeof(int);

  int *tmap = (int *)malloc(tmap_size);
  memset(tmap, 0, tmap_size);

  printf("k = %d, d = %d", k, d);

  int idx = 0;
  char *cp = buf;
  int i;
  for (i = 0; i < k; ++i)
    {
      idx = (idx << 2) + calc(*cp);
      // most recent nucleo is ls-2bits
      ++cp;
    }

  int k_mask = (1 << (2*k)) - 1;
  inc_neighbours(idx, k, d, tmap);

  free(tmap);
  return 0;
}
